\section{Structure of Erlang/OTP Projects}

The smallest unit of organization is the \emph{module}, which is a file ending in \lstinline|*.erl| containing function definitions and module attributes. Note that modules are not namespaced in Erlang\footnote{Elixir works around this by prefixing modules with ``\lstinline|Elixir.|'' and concatenating the names of nested modules with a period.}. Modules related to each other are packaged as an \emph{OTP Application}. There are two kinds of Applications:

\begin{enumerate}
  \item \emph{Active Applications} have their own lifecycle, and include their own \emph{root supervisor} that manages the processes contained within. They are explicitly started as part of another Application. Active Applications are often referred to as just \emph{Applications}.\cite{logan:otp}

  \item \emph{Library Applications} are a collection of related modules that can be imported by other Applications. They are not meant to be started as a separate entity; they passively provide functionality.
\end{enumerate}


It is also possible to start an application as an \emph{included application}, which starts it under [another Application's] own OTP supervisor with its own strategy to restart it.\cite{ferd:anger} Note that there is no standard packaged format but plain directories, and that both Applications and Library Applications share the same directory structure.


\subsection{OTP Releases}

A \emph{Release} is a versioned set of compiled Applications and their dependencies, metadata, and lifecycle scripts. A production Erlang/OTP system usually consists of multiple Applications that may or may not depend on each other, all packaged and deployed together as a Release; usually distributed as a \lstinline|*.tar.gz| archive. The applications that make up a Release are started on one Erlang \emph{Node}, which is an \acrshort{os}-level process running the Release on top of the Erlang \acrshort{vm}. A system that is transferred to and installed at another site is called a \emph{target system}.\cite[347]{d]oc:otp}

A Release is described by a \emph{Release Resource File} \lstinline|*.rel|, which specifies the name and a version of the Release, pins the \acrshort{erts} to a specific version and lists the included applications at specific versions. The Release Resource File is compiled to \lstinline|*.script| and \lstinline|*.boot| files used by the \emph{release handler} process to start the system.


\subsubsection{System Architecture Support Libraries}

The Erlang/\acrshort{otp} distribution includes the \acrfull{sasl} application, which provides low-level services to help generate, package, and install \acrshort{otp} Releases. Specifically, the \lstinline|systools| module writes boot scripts, release upgrade files (\lstinline|relup|), and release packages (\lstinline|*.tar.gz|); while the \lstinline|release_handler| process is responsible for unpacking and installing a Release onto a running system. Consequently, Erlang/OTP systems that plan to use \acrshort{otp} facilities for release handling must depend on \acrshort{sasl}.


\subsubsection{Hot Upgrades Without OTP Releases}

There are ways to perform hot code replacement without using OTP and Releases by interfacing directly with the Erlang Code Server, via the low-level \lstinline|code| module specifically using the \lstinline|code:l/1| ("load") and \lstinline|code:nl/1| ("network load") functions. Both take the name of a compiled \lstinline|*.beam| file and load the code into either the current \acrshort{vm} or into all Nodes connected via the Erlang Distribution Protocol. Doing so is fine in development, however for production deployments the following issues arise:

\begin{enumerate}
\item No \lstinline|code_change| methods of any \acrshort{otp} behaviors are called when using \lstinline|code:l/1| or \lstinline|code:nl/1|.
\item Modules loaded onto connected Nodes with \lstinline|code:nl/1| are wiped when the remote Node restarts.
\item It's hard to determine what code a given Node is running.
\end{enumerate}

