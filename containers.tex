\section{Deterministic Builds}

\subsection{Building in Linux Containers}

\subsubsection{The Command Line Interface Tool}
Since all of the action happens inside containers, the \acrshort{cli} tool can be distributed as a single compact shell script. When the \acrshort{cli} tool is invoked, it acts as a thin wrapper around the Docker client. The script does little more than start a container, and set its environment variables and volume paths. Distributing a single shell script with only one dependency on the Docker client may ease adoption of the proposed tool among developers. Installing the tool on a \acrshort{ci} server can also be made trivial, as Listing \ref{lst:curlpipesh} shows.

\begin{lstlisting}[
  label={lst:curlpipesh},
  caption={CLI tool installation command}
]
curl https://get.beamup.io/install | /bin/sh
\end{lstlisting}

A single line consisting of a controversial\footnote{\url{https://curlpipesh.tumblr.com}} chain of easily copy/pasteable shell commands can download the script and execute it.


\subsection{Non-destructive Editing of Configuration Files}

As described in Section "Automated Versioning" on Page \pageref{tempeditaftercommit}, the build tool needs to make various edits to metadata and configuration files of the project. However, any editing needs to happen non-destructively--i.e. without changing the actual contents of any file in the working tree, and any files created during the build process should be removed on termination. The simplest way to guarantee non-destructiveness is to copy the working tree to a separate scratch location for modifying.

\subsubsection{Bind Mounting the Host's Working Directory}
When the build command is invoked, the \acrshort{cli} wrapper script starts a builder container and bind mounts the current working directory in read-only mode. Restricting the container to only read from the mounted volume guarantees that the host's working always tree stays intact. A bind mount is the most performant way to share files of the host with the container.\cite{docker:docs} However, there is no way to allow temporary changes from within the container which are not propagated to the host's file system, but stay local to the mounted volume inside the container. Since the build tools running inside the container expect to be able to change files, the contents from the bind-mounted working directory need to be copied to another writable location inside the container.

\subsubsection{Temporary Scratch File System}
The container is also assigned a \lstinline|tmpfs| mount, which is a container-accessible volume whose contents are stored in the host's \acrshort{ram} for as long as the container is running.\cite{docker:docs} When the container is started, the contents of the bind mount are copied to the \lstinline|tmpfs| mount where they can be freely edited by the build tools without affecting the files in the original working tree on the host. There is an inital startup performance penalty when copying the working tree to the \lstinline|tmpfs|, however later file operations on the ramdisk are faster.
% TODO: Reference to Latency Measure in Chapter XX
Listing \ref{lst:dockermount} demonstrates running the containerized build process with the current host directory bind mounted at \lstinline|/source| and a \lstinline|tmpfs| ramdisk mounted at \lstinline|/scratch|.

\begin{lstlisting}[
  label={lst:dockermount},
  caption={Mounting a host volume and a scratch disk inside a container}
]
  docker run --rm -it \
    --mount type=bind,source="$(pwd)",target=/source \
    --mount type=tmpfs,destination=/scratch \
    beamup/builder
\end{lstlisting}

