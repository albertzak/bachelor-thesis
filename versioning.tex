\section{Automated Versioning}

The version number of a release must uniquely identify a snapshot of the system's code and its dependencies. Up until now, developers had to manually edit version strings in various files each time they wished to create a release. The current process is error-prone and slow, leading to bigger, less focused releases that are harder to apply. The solution proposed in this section replaces numeric version strings with automatically generated cryptographic hashes of the changesets. Developers are relieved of coordinating versioning, and the system is able to provide uniqueness and identifiability guarantees.

The Erlang/OTP release handling system expects version numbers to exist in various metadata files. Multiple books recommend to use traditional numeric version strings, as they usually can be parsed by some of the existing tooling.\cite[252, 322]{logan:otp, cesarini:otp, ferd}

\subsection{Manually Incrementing Version Numbers}
Currently, developers have to remember to manually increment version numbers before committing a change. This leads to various problems where multiple revisions of the code base share the same version number:

\begin{enumerate}
  \item If a developer forgets to increment the version number, different snapshots of the code base share the same version number, thus breaking uniqueness.
  \item Multiple developers working on a single project in parallel may fail to coordinate the next increment, thus breaking uniqueness.
\end{enumerate}

\subsubsection{Storing Metadata in the Version String}
Version strings have also been used to store various other meta-information about an artefact. Categorizing changes into major and minor based on the developer's assumptions of whether or not a changeset is backwards compatible can certainly be very useful for the consumers of library modules. In 2010, GitHub introduced Semantic Versioning and encouraged \emph{all} software projects to adopt it. However, \cite{rae:semver} found that the current mechanisms to signal interface instability are not used properly.

\subsection{Numeric Versioning Schemes}
On the surface, traditional version numbers seem to have a number of advantages over hashes: They are ordered, and they might provide some information about the release at a glance. However, total order is not guaranteed taking into account the above issues.

\subsubsection{Advantages in Erlang/OTP}
In regards to Erlang/OTP systems, one advantage of numeric versioning schemes is that Erlang has built-in support for comparing version strings. For example, if multiple versions of an application are available, Erlang picks the one with the highest version number. Additionally, application upgrade files (\lstinline|appup|) can specify not only one specific version to upgrade from or downgrade to; but may use regular expressions (regex) to define a range of acceptable source versions.\cite{cesarini:otp}

\subsection{Cryptographic Versioning Schemes}
Replacing traditional numeric version numbers with the cryptographic hash of a commit guarantees uniqueness and reliably links the release with the commit. Version number schemes differ between \acrfull{scm}s. We can't however simply write a commit hash into a version-controlled file, as there is no way to know the hash of a commit before committing.

\subsubsection{Second Commit After Commit}
One rudimentary workaround could be to follow with another commit immediately that writes the hash of the previous commit to the files that need updating. However, doing so would (1) pollute the commit history, and (2) create ambiguity when attempting to checkout the revision of the code as reported by a release.

\subsubsection{Temporary Edit After Commit}
The proposed solution is to keep version numbers out of the \acrfull{scm} repository. Any version-controlled metadata files must not define any version strings identifying any version-controlled code from the same repository. The canonical version string of a revision is its cryptographic commit hash, and is generated once and only after a changeset is finalized. The proposed pipeline is designed to integrate with the Git \acrshort{scm} system. The SHA-1 hashes identifying Git commits are dynamically inserted as version strings in metadata files when building a release. All edits happen on a copy of the code, and are discarded when the build is finished, without ever being persisted in the repository. The process is detailed in the section on Deterministic Builds.

\subsubsection{Identifying Changed Sub-Applications}
Complex Erlang/OTP applications ("umbrella applications") are often split up into several sub-applications, that live in separate directories and are developed and deployed together. Another advantage of using commit hashes as version strings is that it becomes trivial to identify changed sub-applications by retrieving the last commit that changed any file inside a certain directory.

\begin{lstlisting}[
  label={lst:githash},
  caption={Git command to retrieve the hash of the last commit made in a subdirectory}
]
git rev-list -1 HEAD -- "$directory"
\end{lstlisting}


\subsubsection{Dealing With Dirty Working Trees}
There is one issue with the above "temporary edit after commit" solution; when a developer edits a checked out copy, does not commit the changes, and invokes the proposed build pipeline. Git calls this situation a "dirty working tree", and it is a normal occurrence during development. The command given in Listing \ref{lst:githash} would still return the hash of the last commit, even though the state of the files in the working directory has changed since. The build system needs to be able to detect such situations. Since the proposed build pipeline is designed to be run on a \acrshort{ci} server from a "fresh" clone of the repository, the only sensible course of action is to fail if the working tree is dirty.

The build system first needs to invoke the command given in Listing \ref{lst:gitchanges} to determine if any changes were made to tracked (i.e. known to git) files. The exit code \lstinline|0| means that there were no differences, while \lstinline|1| indicates that some tracked files were changed.

\begin{lstlisting}[
  label={lst:gitchanges},
  caption={Git command to check for changes to tracked files}
]
git diff-index --quiet HEAD --
\end{lstlisting}

Any newly created and thus untracked files are not reported by the command in Listing \ref{lst:gitchanges}. To get a list of untracked files, the build system also needs to call the command given in Listing \ref{lst:gituntracked}. Note that now the tool has to parse the output instead of just checking the return code: If there are no untracked files, the output is empty.

\begin{lstlisting}[
  label={lst:gituntracked},
  caption={Git command to print a list of all untracked (new) files}
]
git ls-files --exclude-standard --others
\end{lstlisting}

Both commands in Listings \ref{lst:gitchanges} and \ref{lst:gituntracked} are "plumbing" commands specifically recommended by the Git developers for use in scripts, as their \acrshort{api} is promised to be kept stable.\cite{man:git}
