\chapter{Hot Code Loading in Erlang}

\section{Example}

\lstinputlisting[
  label={lst:loop_example},
  caption={Example of a hot-upgradable Erlang Process},
  firstline=4
]{loop_example.erl}

Listing~\ref{lst:loop_example} shows how state is passed between iterations of a server loop.

The \lstinline{spawn_link/3} function atomically spawns a process and links it to the caller to be notified when the spawned process crashes.

Its three arguments reference the function to run, including the arguments. Such triplets are commonly called \acrfull{mfa}. Note that \lstinline|?MODULE| is a macro which is expanded to the name of the current module. Here, the \lstinline{loop/1} function is given an initial state of \lstinline{0}. When the process receives a message matching the pattern of the tuple \lstinline|{increment, _}|, it calculates the new state, responds, and applies the new state to itself in a tail-recursive call.

Calling the \acrfull{bif} \lstinline|c/1| compiles and loads a new version of a module into memory.
However, any processes spawned so far will continue to run the old version of the code. Note that the Erlang \acrshort{vm}'s code server keeps no more than two pointers to the executable code for each module: One for the old, and one for the current. If a third version of a module is loaded, any processes running the old code are forcibly killed. The only way to switch a process to run a new version of a module is via a \emph{fully-qualified} or \emph{external} call. By prefixing the function call with the module name, the newest loaded version of the module is executed. Calling all functions in a fully-qualified way to always run the newest code would be possible; however doing so would make it impossible to transform state between versions.

In this example, when the process receives a \lstinline{upgrade} message, it may use a fully-qualified call to the new version's upgrade function. The upgrade function transforms the current state into the format that the new version expects. After the state transformation, the process switches itself over to the new module.



\section{Limitations of Hot Code Loading}

\subsection{Receive with No Timeout}

To perform a hot code swap of a module, any processes that run this module's code must be suspended. The \acrshort{vm} can only preempt processes at \emph{reductions}; that is when the process calls any function.\footnote{The term \emph{reduction} comes from Erlang's Prolog heritage. Reductions are roughly equal to function calls, however there are some \acrshort{bif}s that don't count as reductions.} When a process blocks while waiting for a message, it doesn't perform any reductions,  thus can't be suspended, and can't upgrade to the new version of the code.

In practice, this is not a problem when implementing \acrshort{otp} behaviors such as generic servers, as they transparently handle timeouts and code change events. However, developers spoiled by \acrshort{otp} may forget that a plain \lstinline|receive| statement should have a timeout. It should be possible to statically analyze an Erlang codebase for such issues.


\subsection{Messages in Mailboxes May Exist for a Long Time}

Obvious.


\subsection{Records}

Erlang developers often use records to keep complex state. They are nothing but syntactic sugar over tuples. When tuples get too large (eg. more than three elements), it gets confusing to pattern match against elements by index. Erlang records are a way to define names for the elements of a tuple. Using records allows to conveniently pattern match against specific fields by a name instead of their index.

Record declarations are static, they can't be changed at runtime. In fact, records don't even exist at runtime; they are converted to tuples at compile time. There is no language support for changing the structure of a record via a hot upgrade. Records are not versioned. If a record declaration is changed between module versions, an existing record can't be parsed by the new version of the module. There have been attempts to add versioned records to Erlang\footnote{\url{https://github.com/andytill/aversion}} and Elixir\footnote{\url{https://github.com/yrashk/exrecord}}.

Records should be specified local to a single module, but they can also be defined in Erlang header files (\lstinline|*.hrl|) that are shares between modules. \cite{davis:talk} recommends disallowing record definitions in Erlang header files. However, as of the time of publication no public tools exist to statically analyze an erlang codebase for public record definitions. Instead, records that need to be accessible to multiple modules or processes should be encapsulated by their own module. This wrapper module provides functions to get and set fields.

Since version 17, Erlang has \emph{maps}--a first class \emph{associative array} (or \emph{"dictionary"}) data type that allows pattern matching and is more performant than the other key-value data structures\footnote{Key-Value Dictionary as Ordered List (\lstinline|orddict|), Key-Value Dictionary (\lstinline|dict|), General Balanced Trees (\lstinline|gb_trees|)} in Erlang. Maps are designed as a replacement for records, especially for organizing dynamic data such as the state of a process.


\subsection{Anonymous Functions}

Processes may pass anonymous functions to each other. For example, a worker process might accept a message that triggers a network request. To signal completion, the client passes an anonymous function as a \emph{callback} to the worker process.

State may be implicitly passed to the callback in a \emph{closure}. This must not be done when planning to use hot code swapping. Any process that holds a reference to an anonymous function defined in an old module is terminated by the \acrshort{vm}.

\cite{davis:talk} reports that the use of anonymous functions is the most common cause of failed upgrades; and recommends to avoid passing them as long-lived callbacks between processes. Instead, the calling module should specify the callback function in fully-qualified form. The calling module can pass additional arguments as \lstinline|{M,F,A}|; and the callee must then pass through the supplied arguments to the callback, including any additional data, such as the result of the remote call.

However, as such pass-though data is of no concern to the callee, \cite{carlsson:parameterized} argued that it should not affect the implementation of the callee. He proposed to add \emph{parameterized modules} (also called \emph{"abstract modules"}) to Erlang. An experimental implementation made it possible, as in Object Oriented Programming, to define modules with free variables, call a constructor function to instantiate them while passing arguments, and pass references to such module instances as callbacks.
However, parameterized module support was never officially documented and was removed in version R16B.
\footnote{Commit to the Erlang/OTP Repository; \url{https://github.com/erlang/otp/commit/35adf88290339ecdbbcd0a1290032d599bda26c4}, accessed August 20, 2017}
