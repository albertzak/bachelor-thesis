\section{Limitations of Hot Code Loading}

The following subsections describe concerns specific to Erlang. For a more general overview of potential pitfalls in dynamically updating software, refer to \cite{gregersen:phenomena} and \cite{hicks}.

\subsection{Processes Blocking with No Timeouts}

To perform a hot code swap of a module, any processes that run this module's code must be suspended. The \acrshort{vm} can only preempt processes at \emph{reductions}; that is when the process calls any function.\footnote{The term \emph{reduction} comes from Erlang's Prolog heritage. Reductions are roughly equal to function calls, however there are some \acrshort{bif}s that don't count as reductions.} When a process blocks while waiting for a message, it doesn't perform any reductions, thus can't be suspended, and can't upgrade to the new version of the code.

In practice, this is not a problem when implementing \acrshort{otp} behaviors such as generic servers, as they transparently handle timeouts and code change events. However, developers spoiled by \acrshort{otp} may forget that a plain \lstinline|receive| statement should have a timeout. It may be possible to statically analyze an Erlang codebase for such issues.

\subsection{Dependencies and Ordering}

Complicated or circular dependencies can make it difficult or even impossible to decide in which order things must be done without risking runtime errors during an upgrade or downgrade.\cite[352]{doc:otp} Dependencies can exist between modules, processes and nodes.

\subsection{Keeping State in Records}

Erlang developers often use \emph{Records} to keep complex state. They are nothing but syntactic sugar over tuples. When tuples get too large (eg. more than three elements), it gets confusing to pattern match against elements by index. Erlang records are a way to define names for the elements of a tuple. Using records allows to conveniently pattern match against specific fields by a name instead of their index.


\subsubsection{Modifying the Structure of Records}
Record declarations are static and can't be changed at runtime. In fact, records don't even exist at runtime. The Erlang compiler \emph{de-sugars} the record syntax into tuples. There is no language support for changing the structure of a record via a hot upgrade. If a record declaration is changed between module versions, an existing record can't be parsed by the new version of the module.

There have been attempts by the Erlang\footnote{\url{https://github.com/andytill/aversion}} and Elixir\footnote{\url{https://github.com/yrashk/exrecord}} communities to add a notion of versioned records. Another project is the \lstinline|exprecs| \emph{parse transformation} plugin. Note that the official Erlang documentation states: "Programmers are strongly advised not to engage in parse transformations. No support is offered for problems encountered." While useful, manually versioning records should be reserved for exceptionally complex cases. \cite{rebar3appup} developed a way of comparing two compiled \lstinline|*.beam| files and injecting the necessary code for converting between changed record definitions.

\subsubsection{Sharing Record Declarations}
Records should be specified local to a single module, but they can also be defined in Erlang header files (\lstinline|*.hrl|) that are shared between modules. \cite{davis:talk} recommends disallowing record definitions in Erlang header files. Instead, records that need to be accessible to multiple modules or processes should be encapsulated by their own module which provides functions to get and set fields, and transparently handles versioning.

\subsubsection{Using Maps Instead of Records}
Since OTP release 17, Erlang has \emph{maps}--a first class \emph{associative array} or \emph{dictionary} data type that allows pattern matching and is more performant than the other key-value data structures\footnote{Key-Value Dictionary as Ordered List (\lstinline|orddict|), Key-Value Dictionary (\lstinline|dict|), General Balanced Trees (\lstinline|gb_trees|)} in Erlang. Maps are designed as a replacement for records. Since fields can be added or removed at any time, maps are easy to upgrade in a code change function. However, we lose the strictness of records. \cite{ferd} notes that while a bad upgrade between records would crash immediately and loudly, a bad upgrade between maps might silently corrupt state and lead to more obscure bugs later.


\subsection{Passing Anonymous Functions as Callbacks}

Processes may pass anonymous functions to each other. For example, a worker process might accept a message that triggers a network request. To signal completion, the requester passes an anonymous function as a \emph{callback} to the worker process.

State may be implicitly passed to the callback in a \emph{closure}. This must not be done when planning to use hot code swapping. Any process that holds a reference to an anonymous function defined in an old module is terminated by the \acrshort{vm}.

\cite{davis:talk} reports that the use of anonymous functions is the most common cause of failed upgrades; and recommends to avoid passing them as long-lived callbacks between processes. Instead, the calling module should specify the callback function in fully-qualified form. The calling module can pass additional arguments as \lstinline|{M,F,A}|; and the callee must then pass through the supplied arguments to the callback, including any additional data, such as the result of the remote call.

However, as such pass-though data is of no concern to the callee, \cite{carlsson:parameterized} argued that it should not affect the implementation of the callee. He proposed to add \emph{parameterized modules} (also called \emph{"abstract modules"}) to Erlang. An experimental implementation made it possible, as in Object Oriented Programming, to define modules with free variables, call a constructor function to instantiate, and pass references to such module instances as callbacks.
However, parameterized module support was never officially documented and was removed\footnote{Commit to the Erlang/OTP Repository; \url{https://github.com/erlang/otp/commit/35adf88290339ecdbbcd0a1290032d599bda26c4}, accessed August 20, 2017} in version R16\footnote{Note that Erlang/OTP releases before 17.0 followed the version scheme \lstinline|R<major>[B<minor>]|}.
